diff --git a/extmod/modtime.c b/extmod/modtime.c
index 805c2621c..66cd88fc1 100644
--- a/extmod/modtime.c
+++ b/extmod/modtime.c
@@ -29,6 +29,8 @@
 #include "py/runtime.h"
 #include "py/smallint.h"
 #include "extmod/modtime.h"
+#include "string.h"
+#include "uiflow_utility.h"
 
 #if MICROPY_PY_TIME
 
@@ -76,6 +78,42 @@ STATIC mp_obj_t time_localtime(size_t n_args, const mp_obj_t *args) {
 }
 MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_time_localtime_obj, 0, 1, time_localtime);
 
+// localtime([secs])
+// Convert a time expressed in seconds since the Epoch into an 8-tuple which
+// contains: (year, month, mday, hour, minute, second, weekday, yearday)
+// If secs is not provided or None, then the current time is used.
+// - year    is the full year, eg 2000
+// - month   is 1-12
+// - mday    is 1-31
+// - hour    is 0-23
+// - minute  is 0-59
+// - second  is 0-59
+// - weekday is 0-6 for Mon-Sun
+// - yearday is 1-366
+STATIC mp_obj_t time_gmtime(size_t n_args, const mp_obj_t *args) {
+    if (n_args == 0 || args[0] == mp_const_none) {
+        // Get current date and time.
+        return mp_time_gmtime_get();
+    } else {
+        // Convert given seconds to tuple.
+        mp_int_t seconds = mp_obj_get_int(args[0]);
+        timeutils_struct_time_t tm;
+        timeutils_seconds_since_epoch_to_struct_time(seconds, &tm);
+        mp_obj_t tuple[8] = {
+            tuple[0] = mp_obj_new_int(tm.tm_year),
+            tuple[1] = mp_obj_new_int(tm.tm_mon),
+            tuple[2] = mp_obj_new_int(tm.tm_mday),
+            tuple[3] = mp_obj_new_int(tm.tm_hour),
+            tuple[4] = mp_obj_new_int(tm.tm_min),
+            tuple[5] = mp_obj_new_int(tm.tm_sec),
+            tuple[6] = mp_obj_new_int(tm.tm_wday),
+            tuple[7] = mp_obj_new_int(tm.tm_yday),
+        };
+        return mp_obj_new_tuple(8, tuple);
+    }
+}
+MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_time_gmtime_obj, 0, 1, time_gmtime);
+
 // mktime()
 // This is the inverse function of localtime. Its argument is a full 8-tuple
 // which expresses a time as per localtime. It returns an integer which is
@@ -116,6 +154,26 @@ MP_DEFINE_CONST_FUN_OBJ_0(mp_time_time_ns_obj, time_time_ns);
 
 #endif // MICROPY_PY_TIME_TIME_TIME_NS
 
+STATIC mp_obj_t time_timezone(size_t n_args, const mp_obj_t *args) {
+    if (n_args == 0 || args[0] == mp_const_none) {
+        char *tz = getenv("TZ");
+        if (tz == NULL) {
+            return mp_const_none;
+        } else {
+            return mp_obj_new_str(tz, strlen(tz));
+        }
+    } else {
+        char tz[64];
+        snprintf(tz, sizeof(tz), "%s", mp_obj_str_get_str(args[0]));
+        setenv("TZ", tz, 1);
+        tzset();
+
+        nvs_write_str_helper(UIFLOW_NVS_NAMESPACE, "tz", tz);
+        return mp_const_none;
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(time_timezone_obj, 0, 1, time_timezone);
+
 STATIC mp_obj_t time_sleep(mp_obj_t seconds_o) {
     #ifdef MICROPY_PY_TIME_CUSTOM_SLEEP
     mp_time_sleep(seconds_o);
@@ -200,7 +258,7 @@ STATIC const mp_rom_map_elem_t mp_module_time_globals_table[] = {
     { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_time) },
 
     #if MICROPY_PY_TIME_GMTIME_LOCALTIME_MKTIME
-    { MP_ROM_QSTR(MP_QSTR_gmtime), MP_ROM_PTR(&mp_time_localtime_obj) },
+    { MP_ROM_QSTR(MP_QSTR_gmtime), MP_ROM_PTR(&mp_time_gmtime_obj) },
     { MP_ROM_QSTR(MP_QSTR_localtime), MP_ROM_PTR(&mp_time_localtime_obj) },
     { MP_ROM_QSTR(MP_QSTR_mktime), MP_ROM_PTR(&mp_time_mktime_obj) },
     #endif
@@ -210,6 +268,7 @@ STATIC const mp_rom_map_elem_t mp_module_time_globals_table[] = {
     { MP_ROM_QSTR(MP_QSTR_time_ns), MP_ROM_PTR(&mp_time_time_ns_obj) },
     #endif
 
+    { MP_ROM_QSTR(MP_QSTR_timezone), MP_ROM_PTR(&time_timezone_obj) },
     { MP_ROM_QSTR(MP_QSTR_sleep), MP_ROM_PTR(&mp_time_sleep_obj) },
     { MP_ROM_QSTR(MP_QSTR_sleep_ms), MP_ROM_PTR(&mp_time_sleep_ms_obj) },
     { MP_ROM_QSTR(MP_QSTR_sleep_us), MP_ROM_PTR(&mp_time_sleep_us_obj) },
diff --git a/ports/esp32/modtime.c b/ports/esp32/modtime.c
index 7a2b21508..e361a3d64 100644
--- a/ports/esp32/modtime.c
+++ b/ports/esp32/modtime.c
@@ -31,8 +31,8 @@
 #include "py/obj.h"
 #include "shared/timeutils/timeutils.h"
 
-// Return the localtime as an 8-tuple.
-STATIC mp_obj_t mp_time_localtime_get(void) {
+// Return the gmtime as an 8-tuple.
+STATIC mp_obj_t mp_time_gmtime_get(void) {
     struct timeval tv;
     gettimeofday(&tv, NULL);
     timeutils_struct_time_t tm;
@@ -50,6 +50,27 @@ STATIC mp_obj_t mp_time_localtime_get(void) {
     return mp_obj_new_tuple(8, tuple);
 }
 
+
+// Return the localtime as an 8-tuple.
+STATIC mp_obj_t mp_time_localtime_get(void) {
+    time_t rawtime;
+    struct tm *tm;
+    time( &rawtime );
+    tm = localtime( &rawtime );
+
+    mp_obj_t tuple[8] = {
+        tuple[0] = mp_obj_new_int(tm->tm_year + 1900) ,
+        tuple[1] = mp_obj_new_int(tm->tm_mon + 1),
+        tuple[2] = mp_obj_new_int(tm->tm_mday),
+        tuple[3] = mp_obj_new_int(tm->tm_hour),
+        tuple[4] = mp_obj_new_int(tm->tm_min),
+        tuple[5] = mp_obj_new_int(tm->tm_sec),
+        tuple[6] = mp_obj_new_int(tm->tm_wday),
+        tuple[7] = mp_obj_new_int(tm->tm_yday + 1),
+    };
+    return mp_obj_new_tuple(8, tuple);
+}
+
 // Return the number of seconds since the Epoch.
 STATIC mp_obj_t mp_time_time_get(void) {
     struct timeval tv;
diff --git a/ports/esp32/mpconfigport.h b/ports/esp32/mpconfigport.h
index 5dc4a9c75..31cd46f10 100644
--- a/ports/esp32/mpconfigport.h
+++ b/ports/esp32/mpconfigport.h
@@ -88,6 +88,7 @@
 #define MICROPY_GC_SPLIT_HEAP_AUTO          (1)
 
 // extended modules
+#define MICROPY_EPOCH_IS_1970                   (1)
 #ifndef MICROPY_PY_ESPNOW
 #define MICROPY_PY_ESPNOW                   (1)
 #endif
diff --git a/ports/esp32/usb.c b/ports/esp32/usb.c
index 316482e18..14602b22c 100644
--- a/ports/esp32/usb.c
+++ b/ports/esp32/usb.c
@@ -32,9 +32,13 @@
 
 #include "esp_timer.h"
 #ifndef NO_QSTR
+#include "esp_log.h"
 #include "tinyusb.h"
 #include "tusb_cdc_acm.h"
+#include "class/hid/hid.h"
+#include "class/hid/hid_device.h"
 #endif
+#include <stdlib.h>
 
 #define CDC_ITF TINYUSB_CDC_ACM_0
 
@@ -64,9 +68,76 @@ static void usb_callback_rx(int itf, cdcacm_event_t *event) {
     }
 }
 
+#define TUSB_DESC_TOTAL_LEN  (TUD_CONFIG_DESC_LEN + CFG_TUD_HID * TUD_HID_DESC_LEN + CFG_TUD_CDC * TUD_CDC_DESC_LEN)
+enum
+{
+   ITF_NUM_HID,
+   ITF_NUM_CDC_0,
+   ITF_NUM_CDC_0_DATA,
+   ITF_NUM_CDC_1,
+   ITF_NUM_CDC_1_DATA,
+   ITF_NUM_TOTAL
+};
+
+#define EPNUM_HID           0x81
+#define EPNUM_CDC_0_NOTIF   0x82
+#define EPNUM_CDC_0_OUT     0x02
+#define EPNUM_CDC_0_IN      0x83
+
+/**
+ * @brief HID report descriptor
+ *
+ * In this example we implement Keyboard + Mouse HID device,
+ * so we must define both report descriptors
+ */
+const uint8_t hid_report_descriptor[] = {
+    TUD_HID_REPORT_DESC_KEYBOARD(HID_REPORT_ID(HID_ITF_PROTOCOL_KEYBOARD) ),
+    TUD_HID_REPORT_DESC_MOUSE(HID_REPORT_ID(HID_ITF_PROTOCOL_MOUSE) )
+};
+
+/**
+ * @brief Configuration descriptor
+ *
+ * This is a simple configuration descriptor that defines 1 configuration and 1 HID interface
+ */
+static const uint8_t mix_configuration_descriptor[] = {
+    // Configuration number, interface count, string index, total length, attribute, power in mA
+    TUD_CONFIG_DESCRIPTOR(1, 1, 0, TUSB_DESC_TOTAL_LEN, TUSB_DESC_CONFIG_ATT_REMOTE_WAKEUP, 100),
+
+    // Interface number, string index, boot protocol, report descriptor len, EP In address, size & polling interval
+    TUD_HID_DESCRIPTOR(0, 0, false, sizeof(hid_report_descriptor), EPNUM_HID, 16, 10),
+
+    // Interface number, string index, EP notification address and size, EP data address (out, in) and size.
+    TUD_CDC_DESCRIPTOR(ITF_NUM_CDC_0, 0, EPNUM_CDC_0_NOTIF, 8, EPNUM_CDC_0_OUT, EPNUM_CDC_0_IN, 64),
+};
+
+/********* TinyUSB HID callbacks ***************/
+uint8_t const *tud_hid_descriptor_report_cb(uint8_t instance) {
+    // We use only one interface and one HID report descriptor, so we can ignore parameter 'instance'
+    return hid_report_descriptor;
+}
+
+uint16_t tud_hid_get_report_cb(uint8_t instance, uint8_t report_id, hid_report_type_t report_type, uint8_t* buffer, uint16_t reqlen) {
+  (void) instance;
+  (void) report_id;
+  (void) report_type;
+  (void) buffer;
+  (void) reqlen;
+
+  return 0;
+}
+
+void tud_hid_set_report_cb(uint8_t instance, uint8_t report_id, hid_report_type_t report_type, uint8_t const* buffer, uint16_t bufsize) {}
+
 void usb_init(void) {
     // Initialise the USB with defaults.
-    tinyusb_config_t tusb_cfg = {0};
+    const tinyusb_config_t tusb_cfg = {
+        .device_descriptor = NULL,
+        .string_descriptor = NULL,
+        .string_descriptor_count = 0,
+        .external_phy = false,
+        .configuration_descriptor = mix_configuration_descriptor,
+    };
     ESP_ERROR_CHECK(tinyusb_driver_install(&tusb_cfg));
 
     // Initialise the USB serial interface.
